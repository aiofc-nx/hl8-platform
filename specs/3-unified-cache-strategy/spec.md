# Feature Specification: 统一缓存策略

**Feature Branch**: `001-unified-cache-strategy`  
**Created**: 2024-12-03  
**Status**: Draft  
**Input**: User description: "根据前面讨论的内容给我一个统一的、完整的方案"

## User Scenarios & Testing _(mandatory)_

### User Story 1 - 基础设施层仓储查询缓存 (Priority: P1)

开发者在基础设施层使用仓储查询实体时，系统应该自动缓存查询结果，使得后续相同查询可以快速返回缓存数据，避免重复数据库访问。当多个不同的业务用例查询同一实体时，它们可以共享缓存的数据，提高系统性能。

**Why this priority**: 这是核心功能，基础设施层的缓存可以减少数据库压力，提高查询性能，是整体缓存策略的基础。

**Independent Test**: 可以通过调用仓储的 `findById` 方法两次，验证第二次调用是否从缓存返回，并且不访问数据库。可以通过缓存统计接口验证缓存命中率。

**Acceptance Scenarios**:

1. **Given** 系统中存在用户实体 ID 为 "123"，**When** 开发者在用例中调用 `repository.findById(new EntityId("123"))` 两次，**Then** 第一次查询访问数据库，第二次查询从缓存返回，且数据库查询次数仅为 1
2. **Given** 用户实体 "123" 已被缓存，**When** 不同的业务用例（如 GetUserProfileQuery 和 UpdateUserCommand）查询同一用户实体，**Then** 它们共享同一个缓存项，数据库查询次数为 0
3. **Given** 实体数据已被缓存，**When** 实体被更新（通过 save 方法），**Then** 缓存自动失效，下次查询时重新从数据库加载最新数据

---

### User Story 2 - 应用层与基础设施层缓存协同 (Priority: P2)

应用层缓存业务查询结果，基础设施层缓存实体数据，两层缓存协同工作。当应用层缓存未命中但需要查询实体时，可以使用基础设施层缓存的实体数据。当实体更新时，两层缓存能够协调失效，确保数据一致性。

**Why this priority**: 两层缓存协同可以最大化缓存收益，应用层缓存处理复杂查询结果，基础设施层缓存提供基础数据共享。

**Independent Test**: 可以通过执行复杂业务查询（触发应用层缓存）后，再执行简单实体查询（使用基础设施层缓存），验证两层缓存的协同工作。可以通过更新实体验证两层缓存同时失效。

**Acceptance Scenarios**:

1. **Given** 系统执行了 GetUsersByDepartmentQuery（应用层缓存了用户列表），**When** 后续执行 GetUserDetailQuery 查询单个用户详细信息，**Then** 如果用户在列表中，可以直接使用基础设施层缓存的用户实体，避免数据库查询
2. **Given** 用户实体在两层缓存中都有缓存（应用层缓存了查询结果，基础设施层缓存了实体数据），**When** 用户实体被更新，**Then** 两层缓存同时失效，下次查询时都从数据库重新加载
3. **Given** 应用层缓存了包含多个实体的查询结果，**When** 其中某个实体被单独更新，**Then** 基础设施层该实体的缓存失效，应用层相关查询缓存也失效（通过标签或模式匹配）

---

### User Story 3 - 缓存失效策略 (Priority: P2)

系统支持多种缓存失效策略，包括基于时间的自动过期（TTL）、基于事件驱动的失效、基于标签的批量失效、以及基于模式匹配的失效。当实体数据发生变化时，系统能够智能地失效相关缓存，确保数据一致性。

**Why this priority**: 缓存失效策略是确保数据一致性的关键，必须准确及时地失效过期的缓存数据。

**Independent Test**: 可以通过设置缓存 TTL，验证缓存是否在过期后自动失效。可以通过发布领域事件验证事件驱动的缓存失效。可以通过标签失效验证批量缓存失效。

**Acceptance Scenarios**:

1. **Given** 实体数据设置了 TTL 为 1 小时，**When** 1 小时后查询该实体，**Then** 缓存已过期，系统从数据库重新加载数据
2. **Given** 系统中缓存了标签为 "entity:user" 的多个用户实体，**When** 发布 UserUpdatedEvent 领域事件，**Then** 所有标签为 "entity:user" 的缓存自动失效
3. **Given** 应用层缓存了多个查询结果（键格式为 "query:_:user:_"），**When** 用户实体被更新，**Then** 通过模式匹配，所有匹配的查询缓存自动失效
4. **Given** 缓存系统启用了事件驱动失效，**When** 实体通过 Repository.save() 保存，**Then** 相关领域事件被发布，触发缓存失效流程

---

### User Story 4 - 缓存库作为独立基础设施 (Priority: P1)

缓存功能作为独立的基础设施库（`@hl8/cache`）存在，位于 `libs/infra/cache`，被 Application Kernel、Infrastructure Kernel 以及其他功能模块引用。所有需要缓存的模块都通过依赖注入使用同一个缓存服务实例，确保缓存的一致性、可维护性和可测试性。

**Why this priority**: 这是架构设计的基础，缓存作为跨层的基础设施，必须独立设计才能支持所有模块的统一使用，遵循依赖倒置原则和单一职责原则。

**Independent Test**: 可以通过创建独立的缓存库模块，验证 Application Kernel 和 Infrastructure Kernel 都能成功依赖和使用它。可以通过依赖注入验证所有模块共享同一个缓存实例。

**Acceptance Scenarios**:

1. **Given** 缓存库 `@hl8/cache` 已创建在 `libs/infra/cache`，**When** Application Kernel 和 Infrastructure Kernel 在 package.json 中添加依赖，**Then** 两个模块都能成功导入和使用 ICache 接口
2. **Given** 缓存库提供了统一的 ICache 接口和 InMemoryCache 实现，**When** Application Kernel 的 CacheMiddleware 和 Infrastructure Kernel 的 Repository 通过依赖注入获取缓存服务，**Then** 它们使用的是同一个缓存实例，缓存数据可以共享
3. **Given** 系统中存在多个需要缓存的模块（如 Domain Kernel、Application Kernel、Infrastructure Kernel），**When** 它们都通过依赖注入使用 `@hl8/cache`，**Then** 所有模块共享同一个缓存实例，缓存策略统一管理
4. **Given** 需要替换缓存实现（例如从内存缓存切换到 Redis），**When** 只修改 `@hl8/cache` 库的实现，**Then** 所有依赖缓存库的模块无需修改代码，只需更新依赖配置

---

### User Story 5 - 缓存配置和监控 (Priority: P3)

系统管理员可以配置缓存的 TTL、最大缓存大小、失效策略等参数。系统提供缓存统计信息（命中率、缓存大小、失效次数等），帮助管理员了解缓存性能并进行优化。

**Why this priority**: 缓存配置和监控对于生产环境的性能调优和问题排查非常重要。

**Independent Test**: 可以通过修改缓存配置验证配置生效。可以通过查询缓存统计接口验证统计信息的准确性。

**Acceptance Scenarios**:

1. **Given** 系统管理员配置了基础设施层缓存 TTL 为 30 分钟，**When** 实体被缓存后，**Then** 缓存项在 30 分钟后自动过期
2. **Given** 系统运行了一段时间，**When** 管理员查询缓存统计信息，**Then** 系统返回准确的命中率、缓存大小、失效次数等统计数据
3. **Given** 缓存大小达到配置的最大值，**When** 新的缓存项需要被缓存，**Then** 系统按照 LRU 策略淘汰最久未访问的缓存项

---

### Edge Cases

- **缓存失效失败**: 当缓存失效操作失败时，系统如何处理？应该记录错误日志但不影响主流程，可以考虑重试机制
- **缓存键冲突**: 当不同的实体类型使用相同的 ID 值时，如何避免缓存键冲突？应该使用实体类型作为缓存键的一部分
- **分布式环境一致性**: 在分布式环境中，如何保证缓存失效通知到达所有节点？可以使用消息队列或 Redis 发布订阅机制
- **缓存雪崩**: 当大量缓存同时过期时，如何避免大量并发数据库查询？应该实现缓存预热或使用随机 TTL
- **缓存穿透**: 当查询不存在的实体 ID 时，如何避免每次都查询数据库？应该缓存"不存在"的结果（空值缓存）
- **缓存击穿**: 当热点数据缓存过期时，如何避免大量并发查询数据库？应该使用分布式锁或单进程锁

## Requirements _(mandatory)_

### Functional Requirements

- **FR-001**: Infrastructure Kernel 的 Repository 接口必须支持实体查询结果的自动缓存，缓存键格式为 `repo:{entityName}:{entityId}`

- **FR-002**: 缓存功能必须作为独立的基础设施库 `@hl8/cache` 实现，位于 `libs/infra/cache` 目录，遵循基础设施层的设计原则。所有需要缓存的模块（Application Kernel、Infrastructure Kernel、Domain Kernel 等）都通过依赖注入使用该库的 ICache 接口，不得重复实现缓存功能

- **FR-021**: 缓存库 `@hl8/cache` 必须提供统一的 ICache 接口，支持多种实现（InMemoryCache、RedisCache 等），所有实现必须实现相同的接口契约

- **FR-022**: 缓存库必须提供 NestJS 模块集成（CacheModule），支持通过依赖注入在所有模块中使用，确保所有模块共享同一个缓存服务实例

- **FR-023**: Application Kernel 必须将其现有的缓存实现迁移到 `@hl8/cache` 库，不再在 Application Kernel 内部维护缓存实现

- **FR-024**: 缓存库的设计必须遵循依赖倒置原则，只提供接口抽象，具体实现通过依赖注入配置，高层模块不依赖具体实现

- **FR-003**: Infrastructure Kernel 必须支持为不同的仓储方法（如 findById、findAll、findBySpecification）配置不同的缓存策略（TTL、是否缓存等）

- **FR-004**: 系统必须支持实体级别的缓存失效，当实体通过 Repository.save() 或 delete() 方法被修改时，相关缓存必须自动失效

- **FR-005**: 系统必须支持基于标签的批量缓存失效，实体缓存必须包含实体类型标签（如 "entity:user"），支持通过标签失效所有相关缓存

- **FR-006**: 系统必须支持基于模式匹配的缓存失效，当实体更新时，可以通过模式匹配失效应用层的相关查询缓存（如 "query:_:user:_"）

- **FR-007**: 系统必须支持基于领域事件的缓存失效，当发布实体相关的领域事件时，系统能够自动识别并失效相关缓存

- **FR-008**: Infrastructure Kernel 的缓存实现必须对应用层透明，使用 Repository 接口的开发者无需关心缓存细节

- **FR-009**: 系统必须支持缓存统计功能，包括缓存命中率、缓存大小、失效次数等统计信息

- **FR-010**: 系统必须支持可配置的缓存策略，包括 TTL、最大缓存大小、缓存淘汰策略（LRU）等参数

- **FR-011**: 系统必须支持空值缓存（缓存不存在的实体查询结果），防止缓存穿透问题

- **FR-012**: Infrastructure Kernel 必须支持缓存功能的启用和禁用，可以通过配置控制是否启用缓存

- **FR-013**: 系统必须支持缓存预热功能，在系统启动时可以预加载常用的实体数据到缓存

- **FR-014**: 缓存失效操作必须是非阻塞的，失效操作的失败不应影响主业务流程

- **FR-015**: 系统必须支持多租户场景下的缓存隔离，不同租户的数据缓存必须完全隔离

- **FR-016**: Infrastructure Kernel 和 Application Kernel 必须使用相同的缓存库实例（`@hl8/cache`），确保缓存协同工作，避免重复缓存和缓存不一致。所有模块通过依赖注入共享同一个缓存服务实例

- **FR-017**: 系统必须记录缓存操作的日志（缓存命中、缓存未命中、缓存失效等），便于问题排查和性能分析

- **FR-018**: 系统必须支持缓存监控和告警，当缓存命中率低于阈值或缓存大小超过限制时能够发出告警

- **FR-019**: 系统必须支持分布式环境下的缓存一致性，当某个节点失效缓存时，其他节点的相关缓存也应该失效

- **FR-020**: Infrastructure Kernel 的 Repository 实现必须支持事务环境下的缓存处理，在事务提交前缓存的数据应该是事务内的最新数据

### Key Entities _(include if feature involves data)_

- **缓存项 (CacheItem)**: 表示单个缓存项，包含缓存值、过期时间、创建时间、最后访问时间、访问次数、标签列表、元数据等属性

- **缓存配置 (CacheConfig)**: 表示缓存系统的配置，包含默认 TTL、最大缓存大小、是否启用统计、是否启用事件驱动失效、清理间隔、是否启用压缩等属性

- **缓存统计信息 (CacheStats)**: 表示缓存的性能统计信息，包含命中次数、未命中次数、设置次数、删除次数、清理次数、当前缓存大小、最大缓存大小、命中率、最后更新时间等属性

- **缓存失效规则 (CacheInvalidationRule)**: 表示缓存失效的规则配置，包含规则 ID、事件类型、失效策略、键模式、标签列表、条件函数、键生成函数、是否启用、优先级等属性

- **实体缓存键 (EntityCacheKey)**: 表示实体缓存的键，格式为 `repo:{entityName}:{entityId}`，必须包含实体类型以避免缓存键冲突

- **缓存库模块 (CacheModule)**: 表示缓存库的 NestJS 模块，提供依赖注入支持，确保所有模块可以共享同一个缓存服务实例

- **缓存提供者 (CacheProvider)**: 表示缓存的具体实现提供者（如 InMemoryCacheProvider、RedisCacheProvider），通过工厂模式创建缓存实例

## Success Criteria _(mandatory)_

### Measurable Outcomes

- **SC-001**: 在使用缓存的情况下，相同实体的重复查询响应时间减少至少 80%（从数据库查询时间降低到缓存读取时间）

- **SC-002**: 基础设施层缓存命中率在正常业务负载下达到至少 60%（针对高频访问的实体）

- **SC-003**: 当多个业务用例查询同一实体时，数据库查询次数减少至少 50%（通过实体缓存共享实现）

- **SC-004**: 缓存失效操作在 100 毫秒内完成，不阻塞主业务流程

- **SC-005**: 在正常业务负载下，缓存系统导致的额外内存开销不超过系统总内存的 10%

- **SC-006**: 缓存统计信息的查询响应时间不超过 50 毫秒

- **SC-007**: 当实体被更新时，相关缓存在 1 秒内失效（包括基础设施层和应用层缓存）

- **SC-008**: 缓存系统在分布式环境下的缓存一致性保证率达到 99.9%（失效通知的成功率）

- **SC-009**: 系统支持至少 10,000 个并发缓存操作（读取和写入）而不出现性能 degradation

- **SC-010**: 缓存配置的修改能够立即生效，无需重启系统

- **SC-011**: 在多租户场景下，缓存隔离的准确性达到 100%（不同租户的数据不会互相访问）

- **SC-012**: 缓存系统能够处理至少 100 万个不同的缓存项（不同的实体 ID）

## Assumptions

- 缓存库作为独立的基础设施库（`@hl8/cache`）存在，位于 `libs/infra/cache`，遵循基础设施层的设计原则

- Application Kernel、Infrastructure Kernel 以及其他功能模块都依赖 `@hl8/cache` 库，而不是相反

- 缓存库提供统一的 ICache 接口和实现（InMemoryCache、RedisCache 等），所有模块通过依赖注入使用相同的缓存服务

- 系统运行在支持依赖注入的环境中（NestJS），可以通过依赖注入获取缓存服务

- 领域事件系统已经实现，可以通过事件驱动机制触发缓存失效

- 系统支持配置管理，可以通过配置控制缓存行为

- 对于多租户场景，租户上下文已经可以在系统上下文中获取

- 系统的日志系统已经就绪，可以记录缓存相关的日志

- 分布式环境下的缓存一致性可以通过消息队列或 Redis 发布订阅机制实现

- 缓存库的设计遵循依赖倒置原则，高层模块（Application Kernel、Infrastructure Kernel）依赖低层抽象（ICache 接口），而不是具体实现
